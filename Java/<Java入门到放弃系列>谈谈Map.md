# 谈谈Map



作为Javaer，对于Map这个单词绝对不会陌生，无论是开发过程中还是出去面试的时候，都会经常遇到，而最频繁使用和面试提问的无非这么几个，HashMap,  HashTable, ConcurrentHashMap。那么本文就针对这几个知识点做一个归纳和总结。

 

## 从HashMap说起

HashMap是上面提到的几个Map中使用频率最高的了，毕竟需要考虑到多线程并发的场景并不算太多。下面是Map的一个关系图，大家了解一下即可。

![Map](https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/blog/2020-01-16-023552.png)

HashMap在Java8之前和之后有很大差别，在Java8以前，它的数据结构是数组+链表的形式，8以后就变成了数组+链表+红黑树的结构。

这个数组也叫做桶，桶中的每个元素存放的是key-value形式的实例，Java7里面叫做Entry，8里面叫Node。那么当HashMap要进行put操作的时候，首先第一步先判断HashMap是否初始化，没有得话就先初始化；接着，对key求Hash值，依据Hash值求下标，这里补充下下标的计算公式: index = HashCode（Key） & （Length- 1），也就是key的Hash与长度减1。计算完下标后若未发生碰撞，就直接放入桶中，发生碰撞了就以链表的形式放在后面。此时链表长度若达到阈值，且HashMap元素超过最低树化容量，则将链表转成红黑树。若节点已经存在，则用新值替换旧值。若桶满了，就需要resize。

那么这个put的操作引申出几个知识点，首先，

> **HashMap的初始容量是多少？为什么设置成这个值呢？**

翻看源码我们可以看到有这么一个变量DEFAULT_INITIAL_CAPACITY，

```Java
/**
 * The default initial capacity - MUST be a power of two.
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

这个就是HashMap的初始容量，也就是16，为啥用位运算这么骚的写法是因为位运算比算数计算的效率要高。那么为啥用16？看看上面说的下标计算的公式: index = HashCode（Key） & （Length- 1）,当长度为16时候，Length-1的二进制就是1111,是一个所有位都为1的数，而且看上述注释，建议的HashMap的初始长度都是2的幂次方，这种情况下，index的结果等同于HashCode后几位的值。那么**只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的**。

> 另一个问题，Java8里面引入了红黑树，**当链表达到一定长度的时候会转换成红黑树，引入红黑树的好处是什么？这个变换的阈值是多少，为什么是这个值？**

当元素put的时候，首先是要根据哈希函数和长度计算下标的，但**即使哈希函数取得再好，也很难达到元素百分百均匀分布**，那么就有可能**导致 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表**，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。

引入红黑树后，但链表长度大于8时，就会转换成红黑树，若链表元素个数小于等于6时，树结构还原成链表。至于为什么是8，我看到过两个说法，一个是**因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短**。另一个说法是**根据泊松分布，在负载因子默认为0.75的时候，单个hash槽内元素个数为8的概率小于百万分之一，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表**。两种都有道理我觉得哪一种都是可以的。

> **当桶满了的时候，HashMap会进行扩容resize，它是何时并且如何扩容的呢？**

当桶的容量达到长度乘以负载因子的时候就会进行扩容，默认的负载因子为0.75。

```Java
/**
 * The load factor used when none specified in constructor.
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

首先，它会创建一个新的Entry空数组，长度是原数组的2倍。然后遍历原Entry数组，把所有的Entry重新Hash到新数组。这里要进行ReHash的原因是我们知道下标的计算是跟长度有关的，长度不一样了，那么index计算的结果自然也不一样，因此需要重新Hash到新数组，rehash是一个比较耗时的过程。

> **接下来还是插入相关的问题，新的Entry节点在插入链表的时候，是怎么插入的？**

这个问题我是在一篇博客上看到的，之前的确从未考虑过这个问题。**Java8之前是头插法**，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率，**在Java8之后，都是所用尾部插入了。** 由于在扩容的时候会存在条件竞争,如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。用头插法的话，假设原来链表是A指向B指向C，新的链表可能出现B指向A但A同时也指向B。用尾插的方法扩容保持链表元素原油的顺序，就不会出现这种链表成环的问题了。

> put的时候会先判断是否碰撞，那么如何减少碰撞呢？

一般有两个方法，一个是使用扰动函数，让不同对象返回不同hashcode；一个是使用final对象，防止键值改变，并采用合适的equeals方法和hashCode方法，减少碰撞的发生。

上面就是一些关于HashMap的一些简单的知识点，我这里整理的其实也不算太多但还是很实用的（我就知道这么多）。

## HashTable

关于HashTable其实说不了太多，因为说实话反正我是从来没用过。都知道它线程安全，但它用的手段很简单粗暴

