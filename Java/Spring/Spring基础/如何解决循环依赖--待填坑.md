### 如何解决循环依赖？

首先解释下什么是循环依赖，其实很简单，就是有两个类它们互相都依赖了对方，如下所示:

```java
@Component
public class AService {

    @Autowired
    private BService bService;
}
```

```java
@Component
public class BService {
    
    @Autowired
    private AService aService;
}
```

AService和BService显然两者都在内部依赖了对方，单拎出来看仿佛看到了多线程中常见的死锁代码，但很显然Spring解决了这个问题。那么回到上面的代码，首先看看第一行，**earlySingletonExposure**这个变量它会是什么值？

它是有一个条件表达式返回的，一个个来看，首先，mbd.isSingleton()。我们知道Spring默认的Bean的作用域都是单例的，因此这里正常来说都是返回true没问题。第二个，**this.allowCircularReference**，这个变量是标记是否允许循环引用，默认也是true。第三个，调用了一个方法,**isSingletonCurrentlyInCreation(beanName)**，进入该代码可以看出它是返回当前的bean是不是正常创建，显然也是true。因此这个**earlySingletonExposure**返回的就是true。

接下来就进入了if语句的实现里面了，也就是**addSingletonFactory()**这个方法。这个方法的作用是**通过三级缓存提前暴露一个工厂对象**。

```java
/**
 * Add the given singleton factory for building the specified singleton
 * if necessary.
 * <p>To be called for eager registration of singletons, e.g. to be able to
 * resolve circular references.
 * @param beanName the name of the bean
 * @param singletonFactory the factory for the singleton object
 */
protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
   Assert.notNull(singletonFactory, "Singleton factory must not be null");
   synchronized (this.singletonObjects) {
      if (!this.singletonObjects.containsKey(beanName)) {
         this.singletonFactories.put(beanName, singletonFactory);
         this.earlySingletonObjects.remove(beanName);
         this.registeredSingletons.add(beanName);
      }
   }
}
```

为什么说是三级缓存，这就要从**ApplicationContext**的getBean()方法看起了。从这个方法点进去一步步深入会找到一个关键的信息

```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```

这个火箭式一样的代码很好理解，就是一层层的去获取这个bean，首先从**singletonObjects**中获取，这里面存放的是已经完全创建好的单例Bean；如果取不到，那么就往下走，去**earlySingletonObjects**里面取，这个是早起曝光的对象；如果还是没有，那么再去第三级缓存singletonFactory里面获取。那么总的来说，Spring去获取一个bean的时候，其实并不是直接就从容器里面取，而是根据不同的情况，从不同的缓存里面取的。

那么再回到**addSingletonFactory**这个方法，它有两个参数，一个是beanName没什么好说，第二个是这个单例的工厂。用的方法是下面的getEarlyBeanReference()方法。

```java
/**
 * Obtain a reference for early access to the specified bean,
 * typically for the purpose of resolving a circular reference.
 * @param beanName the name of the bean (for error handling purposes)
 * @param mbd the merged bean definition for the bean
 * @param bean the raw bean instance
 * @return the object to expose as bean reference
 */
protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
   Object exposedObject = bean;
   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
      for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {
         exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);
      }
   }
   return exposedObject;
}
```

查看**getEarlyBeanReference()**的实现，发现有两个，一个是spring-beans下的**SmartInstantiationAwareBeanPostProcessor**，一个是spring-aop下的**AbstractAutoProxyCreator**。我们在未使用AOP的情况下，取的还是第一种实现。

```java
default Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
   return bean;
}
```

那么令人惊讶的就是，这方法直接返回了bean，也就是说如果不考虑AOP的话，这个方法啥都没干，就是把实例化创建的对象直接返回了！如果考虑AOP的话调用的是另一个实现:

```java
public Object getEarlyBeanReference(Object bean, String beanName) {
   Object cacheKey = getCacheKey(bean.getClass(), beanName);
   this.earlyProxyReferences.put(cacheKey, bean);
   return wrapIfNecessary(bean, beanName, cacheKey);
}
```

可以看出，如果使用了AOP的话，这个方法返回的实际上是bean的代理，并不是它本身。